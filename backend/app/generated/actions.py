# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off
from __future__ import annotations

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template actions.py.jinja --
from typing import TypeVar
import warnings

from . import types, errors, bases
from ._compat import model_parse
from ._constants import CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED

if TYPE_CHECKING:
    from .client import Prisma
    from .bases import _PrismaModel


_PrismaModelT = TypeVar('_PrismaModelT', bound='_PrismaModel')


class UserActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.User]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await User.prisma().query_raw(
            'SELECT * FROM User WHERE id = $1',
            'bbadfchfja',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.User
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await User.prisma().query_first(
            'SELECT * FROM User WHERE email = $1',
            'dhheabfhf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.UserCreateInput,
        include: Optional[types.UserInclude] = None
    ) -> _PrismaModelT:
        """Create a new User record.

        Parameters
        ----------
        data
            User record data
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The created User record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a User record from just the required fields
        user = await User.prisma().create(
            data={
                # data to create a User record
                'email': 'ggciceaie',
                'username': 'bbehjachib',
                'password': 'cadfabfehe',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.UserCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple User records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of User record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await User.prisma().create_many(
            data=[
                {
                    # data to create a User record
                    'email': 'dgiiaaijj',
                    'username': 'bfaiacjjfc',
                    'password': 'eigcfgbif',
                },
                {
                    # data to create a User record
                    'email': 'bagcfbhiig',
                    'username': 'cghideieh',
                    'password': 'biabhbdai',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single User record.

        Parameters
        ----------
        where
            User filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The deleted User record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().delete(
            where={
                'id': 'idghgaicb',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique User record.

        Parameters
        ----------
        where
            User filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The found User record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().find_unique(
            where={
                'id': 'fjfddhigg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> _PrismaModelT:
        """Find a unique User record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            User filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The found User record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().find_unique_or_raise(
            where={
                'id': 'hjaecfifb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple User records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of User records returned
        skip
            Ignore the first N results
        where
            User filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.User]
            The list of all User records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 User records
        users = await User.prisma().find_many(take=10)

        # find the first 5 User records ordered by the username field
        users = await User.prisma().find_many(
            take=5,
            order={
                'username': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single User record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            User filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.User
            The first User record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second User record ordered by the password field
        user = await User.prisma().find_first(
            skip=1,
            order={
                'password': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single User record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            User filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.User
            The first User record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second User record ordered by the avatar field
        user = await User.prisma().find_first_or_raise(
            skip=1,
            order={
                'avatar': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.UserUpdateInput,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single User record.

        Parameters
        ----------
        data
            User record data specifying what to update
        where
            User filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The updated User record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await User.prisma().update(
            where={
                'id': 'cbbbjbfcii',
            },
            data={
                # data to update the User record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.UserWhereUniqueInput,
        data: types.UserUpsertInput,
        include: Optional[types.UserInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            User filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The created or updated User record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().upsert(
            where={
                'id': 'bbejhfidcb',
            },
            data={
                'create': {
                    'id': 'bbejhfidcb',
                    'email': 'bagcfbhiig',
                    'username': 'cghideieh',
                    'password': 'biabhbdai',
                },
                'update': {
                    'email': 'bagcfbhiig',
                    'username': 'cghideieh',
                    'password': 'biabhbdai',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.UserUpdateManyMutationInput,
        where: types.UserWhereInput,
    ) -> int:
        """Update multiple User records

        Parameters
        ----------
        data
            User data to update the selected User records to
        where
            Filter to select the User records to update

        Returns
        -------
        int
            The total number of User records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all User records
        total = await User.prisma().update_many(
            data={
                'status': enums.UserStatus.ACTIVE
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> int:
        """Count the number of User records present in the database

        Parameters
        ----------
        select
            Select the User fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            User filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await User.prisma().count()

        # results: prisma.types.UserCountAggregateOutput
        results = await User.prisma().count(
            select={
                '_all': True,
                'bannedUntil': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.UserCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> types.UserCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.UserCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> Union[int, types.UserCountAggregateOutput]:
        """Count the number of User records present in the database

        Parameters
        ----------
        select
            Select the User fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            User filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await User.prisma().count()

        # results: prisma.types.UserCountAggregateOutput
        results = await User.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UserCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.UserWhereInput] = None
    ) -> int:
        """Delete multiple User records.

        Parameters
        ----------
        where
            Optional User filter to find the records to be deleted

        Returns
        -------
        int
            The total number of User records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all User records
        total = await User.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.UserScalarFieldKeys'],
        *,
        where: Optional['types.UserWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UserAvgAggregateInput'] = None,
        sum: Optional['types.UserSumAggregateInput'] = None,
        min: Optional['types.UserMinAggregateInput'] = None,
        max: Optional['types.UserMaxAggregateInput'] = None,
        having: Optional['types.UserScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UserCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UserScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.UserScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.UserGroupByOutput']:
        """Group User records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar User fields to group records by
        where
            User filter to select records
        take
            Limit the maximum number of User records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UserGroupByOutput]
            A list of dictionaries representing the User record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group User records by updatedAt values
        # and count how many records are in each group
        results = await User.prisma().group_by(
            ['updatedAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class UserRoleActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.UserRole]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await UserRole.prisma().query_raw(
            'SELECT * FROM UserRole WHERE id = $1',
            'bgeecijdgg',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.UserRole
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await UserRole.prisma().query_first(
            'SELECT * FROM UserRole WHERE role = $1',
            enums.Role.MEMBER,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.UserRoleCreateInput,
        include: Optional[types.UserRoleInclude] = None
    ) -> _PrismaModelT:
        """Create a new UserRole record.

        Parameters
        ----------
        data
            UserRole record data
        include
            Specifies which relations should be loaded on the returned UserRole model

        Returns
        -------
        prisma.models.UserRole
            The created UserRole record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a UserRole record from just the required fields
        userrole = await UserRole.prisma().create(
            data={
                # data to create a UserRole record
                'role': enums.Role.MEMBER,
                'assignedBy': 'bdiicjafbj',
                'userId': 'bgehebiafc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.UserRoleCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple UserRole records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of UserRole record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await UserRole.prisma().create_many(
            data=[
                {
                    # data to create a UserRole record
                    'role': enums.Role.MEMBER,
                    'assignedBy': 'bghffegacj',
                    'userId': 'bhghchehcc',
                },
                {
                    # data to create a UserRole record
                    'role': enums.Role.MEMBER,
                    'assignedBy': 'dcgchcbbf',
                    'userId': 'bdedcabahc',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.UserRoleWhereUniqueInput,
        include: Optional[types.UserRoleInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single UserRole record.

        Parameters
        ----------
        where
            UserRole filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned UserRole model

        Returns
        -------
        prisma.models.UserRole
            The deleted UserRole record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userrole = await UserRole.prisma().delete(
            where={
                'id': 'ghfhiafcb',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.UserRoleWhereUniqueInput,
        include: Optional[types.UserRoleInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique UserRole record.

        Parameters
        ----------
        where
            UserRole filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UserRole model

        Returns
        -------
        prisma.models.UserRole
            The found UserRole record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userrole = await UserRole.prisma().find_unique(
            where={
                'id': 'heejgedji',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.UserRoleWhereUniqueInput,
        include: Optional[types.UserRoleInclude] = None
    ) -> _PrismaModelT:
        """Find a unique UserRole record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            UserRole filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UserRole model

        Returns
        -------
        prisma.models.UserRole
            The found UserRole record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userrole = await UserRole.prisma().find_unique_or_raise(
            where={
                'id': 'bjgjgibgbf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserRoleWhereInput] = None,
        cursor: Optional[types.UserRoleWhereUniqueInput] = None,
        include: Optional[types.UserRoleInclude] = None,
        order: Optional[Union[types.UserRoleOrderByInput, List[types.UserRoleOrderByInput]]] = None,
        distinct: Optional[List[types.UserRoleScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple UserRole records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of UserRole records returned
        skip
            Ignore the first N results
        where
            UserRole filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserRole model
        order
            Order the returned UserRole records by any field
        distinct
            Filter UserRole records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.UserRole]
            The list of all UserRole records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 UserRole records
        userroles = await UserRole.prisma().find_many(take=10)

        # find the first 5 UserRole records ordered by the channelId field
        userroles = await UserRole.prisma().find_many(
            take=5,
            order={
                'channelId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserRoleWhereInput] = None,
        cursor: Optional[types.UserRoleWhereUniqueInput] = None,
        include: Optional[types.UserRoleInclude] = None,
        order: Optional[Union[types.UserRoleOrderByInput, List[types.UserRoleOrderByInput]]] = None,
        distinct: Optional[List[types.UserRoleScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single UserRole record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UserRole filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserRole model
        order
            Order the returned UserRole records by any field
        distinct
            Filter UserRole records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UserRole
            The first UserRole record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UserRole record ordered by the assignedAt field
        userrole = await UserRole.prisma().find_first(
            skip=1,
            order={
                'assignedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserRoleWhereInput] = None,
        cursor: Optional[types.UserRoleWhereUniqueInput] = None,
        include: Optional[types.UserRoleInclude] = None,
        order: Optional[Union[types.UserRoleOrderByInput, List[types.UserRoleOrderByInput]]] = None,
        distinct: Optional[List[types.UserRoleScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single UserRole record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UserRole filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserRole model
        order
            Order the returned UserRole records by any field
        distinct
            Filter UserRole records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UserRole
            The first UserRole record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UserRole record ordered by the assignedBy field
        userrole = await UserRole.prisma().find_first_or_raise(
            skip=1,
            order={
                'assignedBy': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.UserRoleUpdateInput,
        where: types.UserRoleWhereUniqueInput,
        include: Optional[types.UserRoleInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single UserRole record.

        Parameters
        ----------
        data
            UserRole record data specifying what to update
        where
            UserRole filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned UserRole model

        Returns
        -------
        prisma.models.UserRole
            The updated UserRole record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        userrole = await UserRole.prisma().update(
            where={
                'id': 'bbbgbhfjge',
            },
            data={
                # data to update the UserRole record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.UserRoleWhereUniqueInput,
        data: types.UserRoleUpsertInput,
        include: Optional[types.UserRoleInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            UserRole filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned UserRole model

        Returns
        -------
        prisma.models.UserRole
            The created or updated UserRole record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userrole = await UserRole.prisma().upsert(
            where={
                'id': 'igbehcbab',
            },
            data={
                'create': {
                    'id': 'igbehcbab',
                    'role': enums.Role.MEMBER,
                    'assignedBy': 'dcgchcbbf',
                    'userId': 'bdedcabahc',
                },
                'update': {
                    'role': enums.Role.MEMBER,
                    'assignedBy': 'dcgchcbbf',
                    'userId': 'bdedcabahc',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.UserRoleUpdateManyMutationInput,
        where: types.UserRoleWhereInput,
    ) -> int:
        """Update multiple UserRole records

        Parameters
        ----------
        data
            UserRole data to update the selected UserRole records to
        where
            Filter to select the UserRole records to update

        Returns
        -------
        int
            The total number of UserRole records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all UserRole records
        total = await UserRole.prisma().update_many(
            data={
                'userId': 'bdadaadhag'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserRoleWhereInput] = None,
        cursor: Optional[types.UserRoleWhereUniqueInput] = None,
    ) -> int:
        """Count the number of UserRole records present in the database

        Parameters
        ----------
        select
            Select the UserRole fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserRole filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserRoleCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UserRole.prisma().count()

        # results: prisma.types.UserRoleCountAggregateOutput
        results = await UserRole.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.UserRoleCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserRoleWhereInput] = None,
        cursor: Optional[types.UserRoleWhereUniqueInput] = None,
    ) -> types.UserRoleCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.UserRoleCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserRoleWhereInput] = None,
        cursor: Optional[types.UserRoleWhereUniqueInput] = None,
    ) -> Union[int, types.UserRoleCountAggregateOutput]:
        """Count the number of UserRole records present in the database

        Parameters
        ----------
        select
            Select the UserRole fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserRole filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserRoleCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UserRole.prisma().count()

        # results: prisma.types.UserRoleCountAggregateOutput
        results = await UserRole.prisma().count(
            select={
                '_all': True,
                'role': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UserRoleCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.UserRoleWhereInput] = None
    ) -> int:
        """Delete multiple UserRole records.

        Parameters
        ----------
        where
            Optional UserRole filter to find the records to be deleted

        Returns
        -------
        int
            The total number of UserRole records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all UserRole records
        total = await UserRole.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.UserRoleScalarFieldKeys'],
        *,
        where: Optional['types.UserRoleWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UserRoleAvgAggregateInput'] = None,
        sum: Optional['types.UserRoleSumAggregateInput'] = None,
        min: Optional['types.UserRoleMinAggregateInput'] = None,
        max: Optional['types.UserRoleMaxAggregateInput'] = None,
        having: Optional['types.UserRoleScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UserRoleCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UserRoleScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.UserRoleScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.UserRoleGroupByOutput']:
        """Group UserRole records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar UserRole fields to group records by
        where
            UserRole filter to select records
        take
            Limit the maximum number of UserRole records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UserRoleGroupByOutput]
            A list of dictionaries representing the UserRole record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group UserRole records by channelId values
        # and count how many records are in each group
        results = await UserRole.prisma().group_by(
            ['channelId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class AdminActionActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.AdminAction]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await AdminAction.prisma().query_raw(
            'SELECT * FROM AdminAction WHERE id = $1',
            'bgiggdidbf',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.AdminAction
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await AdminAction.prisma().query_first(
            'SELECT * FROM AdminAction WHERE action = $1',
            enums.AdminActionType.BAN_USER,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.AdminActionCreateInput,
        include: Optional[types.AdminActionInclude] = None
    ) -> _PrismaModelT:
        """Create a new AdminAction record.

        Parameters
        ----------
        data
            AdminAction record data
        include
            Specifies which relations should be loaded on the returned AdminAction model

        Returns
        -------
        prisma.models.AdminAction
            The created AdminAction record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a AdminAction record from just the required fields
        adminaction = await AdminAction.prisma().create(
            data={
                # data to create a AdminAction record
                'action': enums.AdminActionType.BAN_USER,
                'targetType': enums.AdminTargetType.USER,
                'targetId': 'caaaedabfc',
                'adminId': 'bigibebcib',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.AdminActionCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple AdminAction records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of AdminAction record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await AdminAction.prisma().create_many(
            data=[
                {
                    # data to create a AdminAction record
                    'action': enums.AdminActionType.BAN_USER,
                    'targetType': enums.AdminTargetType.USER,
                    'targetId': 'bigaiehgcc',
                    'adminId': 'beeifcbebf',
                },
                {
                    # data to create a AdminAction record
                    'action': enums.AdminActionType.BAN_USER,
                    'targetType': enums.AdminTargetType.USER,
                    'targetId': 'bgcigfahea',
                    'adminId': 'bcejgaggif',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.AdminActionWhereUniqueInput,
        include: Optional[types.AdminActionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single AdminAction record.

        Parameters
        ----------
        where
            AdminAction filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned AdminAction model

        Returns
        -------
        prisma.models.AdminAction
            The deleted AdminAction record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        adminaction = await AdminAction.prisma().delete(
            where={
                'id': 'idfjadbcc',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.AdminActionWhereUniqueInput,
        include: Optional[types.AdminActionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique AdminAction record.

        Parameters
        ----------
        where
            AdminAction filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned AdminAction model

        Returns
        -------
        prisma.models.AdminAction
            The found AdminAction record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        adminaction = await AdminAction.prisma().find_unique(
            where={
                'id': 'hgdhbjhhj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.AdminActionWhereUniqueInput,
        include: Optional[types.AdminActionInclude] = None
    ) -> _PrismaModelT:
        """Find a unique AdminAction record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            AdminAction filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned AdminAction model

        Returns
        -------
        prisma.models.AdminAction
            The found AdminAction record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        adminaction = await AdminAction.prisma().find_unique_or_raise(
            where={
                'id': 'ecjjjfbae',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AdminActionWhereInput] = None,
        cursor: Optional[types.AdminActionWhereUniqueInput] = None,
        include: Optional[types.AdminActionInclude] = None,
        order: Optional[Union[types.AdminActionOrderByInput, List[types.AdminActionOrderByInput]]] = None,
        distinct: Optional[List[types.AdminActionScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple AdminAction records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of AdminAction records returned
        skip
            Ignore the first N results
        where
            AdminAction filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AdminAction model
        order
            Order the returned AdminAction records by any field
        distinct
            Filter AdminAction records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.AdminAction]
            The list of all AdminAction records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 AdminAction records
        adminactions = await AdminAction.prisma().find_many(take=10)

        # find the first 5 AdminAction records ordered by the targetType field
        adminactions = await AdminAction.prisma().find_many(
            take=5,
            order={
                'targetType': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AdminActionWhereInput] = None,
        cursor: Optional[types.AdminActionWhereUniqueInput] = None,
        include: Optional[types.AdminActionInclude] = None,
        order: Optional[Union[types.AdminActionOrderByInput, List[types.AdminActionOrderByInput]]] = None,
        distinct: Optional[List[types.AdminActionScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single AdminAction record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            AdminAction filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AdminAction model
        order
            Order the returned AdminAction records by any field
        distinct
            Filter AdminAction records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.AdminAction
            The first AdminAction record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second AdminAction record ordered by the targetId field
        adminaction = await AdminAction.prisma().find_first(
            skip=1,
            order={
                'targetId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AdminActionWhereInput] = None,
        cursor: Optional[types.AdminActionWhereUniqueInput] = None,
        include: Optional[types.AdminActionInclude] = None,
        order: Optional[Union[types.AdminActionOrderByInput, List[types.AdminActionOrderByInput]]] = None,
        distinct: Optional[List[types.AdminActionScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single AdminAction record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            AdminAction filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AdminAction model
        order
            Order the returned AdminAction records by any field
        distinct
            Filter AdminAction records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.AdminAction
            The first AdminAction record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second AdminAction record ordered by the reason field
        adminaction = await AdminAction.prisma().find_first_or_raise(
            skip=1,
            order={
                'reason': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.AdminActionUpdateInput,
        where: types.AdminActionWhereUniqueInput,
        include: Optional[types.AdminActionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single AdminAction record.

        Parameters
        ----------
        data
            AdminAction record data specifying what to update
        where
            AdminAction filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned AdminAction model

        Returns
        -------
        prisma.models.AdminAction
            The updated AdminAction record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        adminaction = await AdminAction.prisma().update(
            where={
                'id': 'bhhfibbigf',
            },
            data={
                # data to update the AdminAction record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.AdminActionWhereUniqueInput,
        data: types.AdminActionUpsertInput,
        include: Optional[types.AdminActionInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            AdminAction filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned AdminAction model

        Returns
        -------
        prisma.models.AdminAction
            The created or updated AdminAction record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        adminaction = await AdminAction.prisma().upsert(
            where={
                'id': 'ijdbeffgg',
            },
            data={
                'create': {
                    'id': 'ijdbeffgg',
                    'action': enums.AdminActionType.BAN_USER,
                    'targetType': enums.AdminTargetType.USER,
                    'targetId': 'bgcigfahea',
                    'adminId': 'bcejgaggif',
                },
                'update': {
                    'action': enums.AdminActionType.BAN_USER,
                    'targetType': enums.AdminTargetType.USER,
                    'targetId': 'bgcigfahea',
                    'adminId': 'bcejgaggif',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.AdminActionUpdateManyMutationInput,
        where: types.AdminActionWhereInput,
    ) -> int:
        """Update multiple AdminAction records

        Parameters
        ----------
        data
            AdminAction data to update the selected AdminAction records to
        where
            Filter to select the AdminAction records to update

        Returns
        -------
        int
            The total number of AdminAction records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all AdminAction records
        total = await AdminAction.prisma().update_many(
            data={
                'metadata': Json({'jjfeafhfj': True})
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AdminActionWhereInput] = None,
        cursor: Optional[types.AdminActionWhereUniqueInput] = None,
    ) -> int:
        """Count the number of AdminAction records present in the database

        Parameters
        ----------
        select
            Select the AdminAction fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            AdminAction filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AdminActionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await AdminAction.prisma().count()

        # results: prisma.types.AdminActionCountAggregateOutput
        results = await AdminAction.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.AdminActionCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AdminActionWhereInput] = None,
        cursor: Optional[types.AdminActionWhereUniqueInput] = None,
    ) -> types.AdminActionCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.AdminActionCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AdminActionWhereInput] = None,
        cursor: Optional[types.AdminActionWhereUniqueInput] = None,
    ) -> Union[int, types.AdminActionCountAggregateOutput]:
        """Count the number of AdminAction records present in the database

        Parameters
        ----------
        select
            Select the AdminAction fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            AdminAction filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AdminActionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await AdminAction.prisma().count()

        # results: prisma.types.AdminActionCountAggregateOutput
        results = await AdminAction.prisma().count(
            select={
                '_all': True,
                'adminId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.AdminActionCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.AdminActionWhereInput] = None
    ) -> int:
        """Delete multiple AdminAction records.

        Parameters
        ----------
        where
            Optional AdminAction filter to find the records to be deleted

        Returns
        -------
        int
            The total number of AdminAction records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all AdminAction records
        total = await AdminAction.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.AdminActionScalarFieldKeys'],
        *,
        where: Optional['types.AdminActionWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.AdminActionAvgAggregateInput'] = None,
        sum: Optional['types.AdminActionSumAggregateInput'] = None,
        min: Optional['types.AdminActionMinAggregateInput'] = None,
        max: Optional['types.AdminActionMaxAggregateInput'] = None,
        having: Optional['types.AdminActionScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.AdminActionCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.AdminActionScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.AdminActionScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.AdminActionGroupByOutput']:
        """Group AdminAction records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar AdminAction fields to group records by
        where
            AdminAction filter to select records
        take
            Limit the maximum number of AdminAction records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.AdminActionGroupByOutput]
            A list of dictionaries representing the AdminAction record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group AdminAction records by id values
        # and count how many records are in each group
        results = await AdminAction.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ChannelActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Channel]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Channel.prisma().query_raw(
            'SELECT * FROM Channel WHERE id = $1',
            'cbachdgfce',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Channel
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Channel.prisma().query_first(
            'SELECT * FROM Channel WHERE name = $1',
            'chbfcacbd',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ChannelCreateInput,
        include: Optional[types.ChannelInclude] = None
    ) -> _PrismaModelT:
        """Create a new Channel record.

        Parameters
        ----------
        data
            Channel record data
        include
            Specifies which relations should be loaded on the returned Channel model

        Returns
        -------
        prisma.models.Channel
            The created Channel record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Channel record from just the required fields
        channel = await Channel.prisma().create(
            data={
                # data to create a Channel record
                'name': 'efggddide',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ChannelCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Channel records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Channel record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Channel.prisma().create_many(
            data=[
                {
                    # data to create a Channel record
                    'name': 'caficfigfb',
                },
                {
                    # data to create a Channel record
                    'name': 'bfidgijfjc',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ChannelWhereUniqueInput,
        include: Optional[types.ChannelInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Channel record.

        Parameters
        ----------
        where
            Channel filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Channel model

        Returns
        -------
        prisma.models.Channel
            The deleted Channel record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        channel = await Channel.prisma().delete(
            where={
                'id': 'ihieecagf',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ChannelWhereUniqueInput,
        include: Optional[types.ChannelInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Channel record.

        Parameters
        ----------
        where
            Channel filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Channel model

        Returns
        -------
        prisma.models.Channel
            The found Channel record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        channel = await Channel.prisma().find_unique(
            where={
                'id': 'bghfciaafe',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ChannelWhereUniqueInput,
        include: Optional[types.ChannelInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Channel record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Channel filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Channel model

        Returns
        -------
        prisma.models.Channel
            The found Channel record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        channel = await Channel.prisma().find_unique_or_raise(
            where={
                'id': 'bgchfhgceh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ChannelWhereInput] = None,
        cursor: Optional[types.ChannelWhereUniqueInput] = None,
        include: Optional[types.ChannelInclude] = None,
        order: Optional[Union[types.ChannelOrderByInput, List[types.ChannelOrderByInput]]] = None,
        distinct: Optional[List[types.ChannelScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Channel records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Channel records returned
        skip
            Ignore the first N results
        where
            Channel filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Channel model
        order
            Order the returned Channel records by any field
        distinct
            Filter Channel records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Channel]
            The list of all Channel records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Channel records
        channels = await Channel.prisma().find_many(take=10)

        # find the first 5 Channel records ordered by the description field
        channels = await Channel.prisma().find_many(
            take=5,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ChannelWhereInput] = None,
        cursor: Optional[types.ChannelWhereUniqueInput] = None,
        include: Optional[types.ChannelInclude] = None,
        order: Optional[Union[types.ChannelOrderByInput, List[types.ChannelOrderByInput]]] = None,
        distinct: Optional[List[types.ChannelScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Channel record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Channel filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Channel model
        order
            Order the returned Channel records by any field
        distinct
            Filter Channel records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Channel
            The first Channel record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Channel record ordered by the createdAt field
        channel = await Channel.prisma().find_first(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ChannelWhereInput] = None,
        cursor: Optional[types.ChannelWhereUniqueInput] = None,
        include: Optional[types.ChannelInclude] = None,
        order: Optional[Union[types.ChannelOrderByInput, List[types.ChannelOrderByInput]]] = None,
        distinct: Optional[List[types.ChannelScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Channel record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Channel filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Channel model
        order
            Order the returned Channel records by any field
        distinct
            Filter Channel records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Channel
            The first Channel record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Channel record ordered by the updatedAt field
        channel = await Channel.prisma().find_first_or_raise(
            skip=1,
            order={
                'updatedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ChannelUpdateInput,
        where: types.ChannelWhereUniqueInput,
        include: Optional[types.ChannelInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Channel record.

        Parameters
        ----------
        data
            Channel record data specifying what to update
        where
            Channel filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Channel model

        Returns
        -------
        prisma.models.Channel
            The updated Channel record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        channel = await Channel.prisma().update(
            where={
                'id': 'cafeiaccbc',
            },
            data={
                # data to update the Channel record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ChannelWhereUniqueInput,
        data: types.ChannelUpsertInput,
        include: Optional[types.ChannelInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Channel filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Channel model

        Returns
        -------
        prisma.models.Channel
            The created or updated Channel record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        channel = await Channel.prisma().upsert(
            where={
                'id': 'gaddfhfh',
            },
            data={
                'create': {
                    'id': 'gaddfhfh',
                    'name': 'bfidgijfjc',
                },
                'update': {
                    'name': 'bfidgijfjc',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ChannelUpdateManyMutationInput,
        where: types.ChannelWhereInput,
    ) -> int:
        """Update multiple Channel records

        Parameters
        ----------
        data
            Channel data to update the selected Channel records to
        where
            Filter to select the Channel records to update

        Returns
        -------
        int
            The total number of Channel records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Channel records
        total = await Channel.prisma().update_many(
            data={
                'id': 'gieegcbeg'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ChannelWhereInput] = None,
        cursor: Optional[types.ChannelWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Channel records present in the database

        Parameters
        ----------
        select
            Select the Channel fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Channel filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ChannelCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Channel.prisma().count()

        # results: prisma.types.ChannelCountAggregateOutput
        results = await Channel.prisma().count(
            select={
                '_all': True,
                'name': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ChannelCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ChannelWhereInput] = None,
        cursor: Optional[types.ChannelWhereUniqueInput] = None,
    ) -> types.ChannelCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ChannelCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ChannelWhereInput] = None,
        cursor: Optional[types.ChannelWhereUniqueInput] = None,
    ) -> Union[int, types.ChannelCountAggregateOutput]:
        """Count the number of Channel records present in the database

        Parameters
        ----------
        select
            Select the Channel fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Channel filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ChannelCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Channel.prisma().count()

        # results: prisma.types.ChannelCountAggregateOutput
        results = await Channel.prisma().count(
            select={
                '_all': True,
                'description': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ChannelCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ChannelWhereInput] = None
    ) -> int:
        """Delete multiple Channel records.

        Parameters
        ----------
        where
            Optional Channel filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Channel records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Channel records
        total = await Channel.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ChannelScalarFieldKeys'],
        *,
        where: Optional['types.ChannelWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ChannelAvgAggregateInput'] = None,
        sum: Optional['types.ChannelSumAggregateInput'] = None,
        min: Optional['types.ChannelMinAggregateInput'] = None,
        max: Optional['types.ChannelMaxAggregateInput'] = None,
        having: Optional['types.ChannelScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ChannelCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ChannelScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.ChannelScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.ChannelGroupByOutput']:
        """Group Channel records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Channel fields to group records by
        where
            Channel filter to select records
        take
            Limit the maximum number of Channel records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ChannelGroupByOutput]
            A list of dictionaries representing the Channel record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Channel records by createdAt values
        # and count how many records are in each group
        results = await Channel.prisma().group_by(
            ['createdAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class MessageActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Message]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Message.prisma().query_raw(
            'SELECT * FROM Message WHERE id = $1',
            'bgcffadich',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Message
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Message.prisma().query_first(
            'SELECT * FROM Message WHERE content = $1',
            'fcbichhci',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.MessageCreateInput,
        include: Optional[types.MessageInclude] = None
    ) -> _PrismaModelT:
        """Create a new Message record.

        Parameters
        ----------
        data
            Message record data
        include
            Specifies which relations should be loaded on the returned Message model

        Returns
        -------
        prisma.models.Message
            The created Message record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Message record from just the required fields
        message = await Message.prisma().create(
            data={
                # data to create a Message record
                'content': 'bcggadccgf',
                'userId': 'jdcfdcgc',
                'channelId': 'cafdaehjid',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.MessageCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Message records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Message record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Message.prisma().create_many(
            data=[
                {
                    # data to create a Message record
                    'content': 'gifdddbia',
                    'userId': 'bchehecef',
                    'channelId': 'jeijcbhfe',
                },
                {
                    # data to create a Message record
                    'content': 'bjgejjabff',
                    'userId': 'bcciijbibg',
                    'channelId': 'cffcachfd',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.MessageWhereUniqueInput,
        include: Optional[types.MessageInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Message record.

        Parameters
        ----------
        where
            Message filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Message model

        Returns
        -------
        prisma.models.Message
            The deleted Message record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        message = await Message.prisma().delete(
            where={
                'id': 'bccdfhdigc',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.MessageWhereUniqueInput,
        include: Optional[types.MessageInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Message record.

        Parameters
        ----------
        where
            Message filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Message model

        Returns
        -------
        prisma.models.Message
            The found Message record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        message = await Message.prisma().find_unique(
            where={
                'id': 'febcgjbfj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.MessageWhereUniqueInput,
        include: Optional[types.MessageInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Message record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Message filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Message model

        Returns
        -------
        prisma.models.Message
            The found Message record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        message = await Message.prisma().find_unique_or_raise(
            where={
                'id': 'bageiegghg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MessageWhereInput] = None,
        cursor: Optional[types.MessageWhereUniqueInput] = None,
        include: Optional[types.MessageInclude] = None,
        order: Optional[Union[types.MessageOrderByInput, List[types.MessageOrderByInput]]] = None,
        distinct: Optional[List[types.MessageScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Message records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Message records returned
        skip
            Ignore the first N results
        where
            Message filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Message model
        order
            Order the returned Message records by any field
        distinct
            Filter Message records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Message]
            The list of all Message records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Message records
        messages = await Message.prisma().find_many(take=10)

        # find the first 5 Message records ordered by the isEdited field
        messages = await Message.prisma().find_many(
            take=5,
            order={
                'isEdited': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.MessageWhereInput] = None,
        cursor: Optional[types.MessageWhereUniqueInput] = None,
        include: Optional[types.MessageInclude] = None,
        order: Optional[Union[types.MessageOrderByInput, List[types.MessageOrderByInput]]] = None,
        distinct: Optional[List[types.MessageScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Message record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Message filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Message model
        order
            Order the returned Message records by any field
        distinct
            Filter Message records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Message
            The first Message record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Message record ordered by the createdAt field
        message = await Message.prisma().find_first(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.MessageWhereInput] = None,
        cursor: Optional[types.MessageWhereUniqueInput] = None,
        include: Optional[types.MessageInclude] = None,
        order: Optional[Union[types.MessageOrderByInput, List[types.MessageOrderByInput]]] = None,
        distinct: Optional[List[types.MessageScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Message record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Message filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Message model
        order
            Order the returned Message records by any field
        distinct
            Filter Message records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Message
            The first Message record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Message record ordered by the updatedAt field
        message = await Message.prisma().find_first_or_raise(
            skip=1,
            order={
                'updatedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.MessageUpdateInput,
        where: types.MessageWhereUniqueInput,
        include: Optional[types.MessageInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Message record.

        Parameters
        ----------
        data
            Message record data specifying what to update
        where
            Message filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Message model

        Returns
        -------
        prisma.models.Message
            The updated Message record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        message = await Message.prisma().update(
            where={
                'id': 'faidicegb',
            },
            data={
                # data to update the Message record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.MessageWhereUniqueInput,
        data: types.MessageUpsertInput,
        include: Optional[types.MessageInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Message filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Message model

        Returns
        -------
        prisma.models.Message
            The created or updated Message record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        message = await Message.prisma().upsert(
            where={
                'id': 'bacecgfhbe',
            },
            data={
                'create': {
                    'id': 'bacecgfhbe',
                    'content': 'bjgejjabff',
                    'userId': 'bcciijbibg',
                    'channelId': 'cffcachfd',
                },
                'update': {
                    'content': 'bjgejjabff',
                    'userId': 'bcciijbibg',
                    'channelId': 'cffcachfd',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.MessageUpdateManyMutationInput,
        where: types.MessageWhereInput,
    ) -> int:
        """Update multiple Message records

        Parameters
        ----------
        data
            Message data to update the selected Message records to
        where
            Filter to select the Message records to update

        Returns
        -------
        int
            The total number of Message records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Message records
        total = await Message.prisma().update_many(
            data={
                'userId': 'ihcahiead'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MessageWhereInput] = None,
        cursor: Optional[types.MessageWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Message records present in the database

        Parameters
        ----------
        select
            Select the Message fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Message filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.MessageCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Message.prisma().count()

        # results: prisma.types.MessageCountAggregateOutput
        results = await Message.prisma().count(
            select={
                '_all': True,
                'channelId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.MessageCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MessageWhereInput] = None,
        cursor: Optional[types.MessageWhereUniqueInput] = None,
    ) -> types.MessageCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.MessageCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MessageWhereInput] = None,
        cursor: Optional[types.MessageWhereUniqueInput] = None,
    ) -> Union[int, types.MessageCountAggregateOutput]:
        """Count the number of Message records present in the database

        Parameters
        ----------
        select
            Select the Message fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Message filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.MessageCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Message.prisma().count()

        # results: prisma.types.MessageCountAggregateOutput
        results = await Message.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.MessageCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.MessageWhereInput] = None
    ) -> int:
        """Delete multiple Message records.

        Parameters
        ----------
        where
            Optional Message filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Message records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Message records
        total = await Message.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.MessageScalarFieldKeys'],
        *,
        where: Optional['types.MessageWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.MessageAvgAggregateInput'] = None,
        sum: Optional['types.MessageSumAggregateInput'] = None,
        min: Optional['types.MessageMinAggregateInput'] = None,
        max: Optional['types.MessageMaxAggregateInput'] = None,
        having: Optional['types.MessageScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.MessageCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.MessageScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.MessageScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.MessageGroupByOutput']:
        """Group Message records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Message fields to group records by
        where
            Message filter to select records
        take
            Limit the maximum number of Message records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.MessageGroupByOutput]
            A list of dictionaries representing the Message record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Message records by content values
        # and count how many records are in each group
        results = await Message.prisma().group_by(
            ['content'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ChannelMemberActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.ChannelMember]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await ChannelMember.prisma().query_raw(
            'SELECT * FROM ChannelMember WHERE id = $1',
            'biheheiajg',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.ChannelMember
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await ChannelMember.prisma().query_first(
            'SELECT * FROM ChannelMember WHERE joinedAt = $1',
            datetime.datetime.utcnow(),
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ChannelMemberCreateInput,
        include: Optional[types.ChannelMemberInclude] = None
    ) -> _PrismaModelT:
        """Create a new ChannelMember record.

        Parameters
        ----------
        data
            ChannelMember record data
        include
            Specifies which relations should be loaded on the returned ChannelMember model

        Returns
        -------
        prisma.models.ChannelMember
            The created ChannelMember record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a ChannelMember record from just the required fields
        channelmember = await ChannelMember.prisma().create(
            data={
                # data to create a ChannelMember record
                'userId': 'jbgijghgb',
                'channelId': 'hgjcghfbi',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ChannelMemberCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple ChannelMember records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of ChannelMember record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await ChannelMember.prisma().create_many(
            data=[
                {
                    # data to create a ChannelMember record
                    'userId': 'icadbcehj',
                    'channelId': 'jchciaee',
                },
                {
                    # data to create a ChannelMember record
                    'userId': 'deeificjd',
                    'channelId': 'bbcbhebbda',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ChannelMemberWhereUniqueInput,
        include: Optional[types.ChannelMemberInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single ChannelMember record.

        Parameters
        ----------
        where
            ChannelMember filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned ChannelMember model

        Returns
        -------
        prisma.models.ChannelMember
            The deleted ChannelMember record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        channelmember = await ChannelMember.prisma().delete(
            where={
                'id': 'bejfijgcfb',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ChannelMemberWhereUniqueInput,
        include: Optional[types.ChannelMemberInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique ChannelMember record.

        Parameters
        ----------
        where
            ChannelMember filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ChannelMember model

        Returns
        -------
        prisma.models.ChannelMember
            The found ChannelMember record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        channelmember = await ChannelMember.prisma().find_unique(
            where={
                'id': 'caifcbgii',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ChannelMemberWhereUniqueInput,
        include: Optional[types.ChannelMemberInclude] = None
    ) -> _PrismaModelT:
        """Find a unique ChannelMember record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            ChannelMember filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ChannelMember model

        Returns
        -------
        prisma.models.ChannelMember
            The found ChannelMember record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        channelmember = await ChannelMember.prisma().find_unique_or_raise(
            where={
                'id': 'igaibbfgj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ChannelMemberWhereInput] = None,
        cursor: Optional[types.ChannelMemberWhereUniqueInput] = None,
        include: Optional[types.ChannelMemberInclude] = None,
        order: Optional[Union[types.ChannelMemberOrderByInput, List[types.ChannelMemberOrderByInput]]] = None,
        distinct: Optional[List[types.ChannelMemberScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple ChannelMember records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of ChannelMember records returned
        skip
            Ignore the first N results
        where
            ChannelMember filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ChannelMember model
        order
            Order the returned ChannelMember records by any field
        distinct
            Filter ChannelMember records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.ChannelMember]
            The list of all ChannelMember records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 ChannelMember records
        channelmembers = await ChannelMember.prisma().find_many(take=10)

        # find the first 5 ChannelMember records ordered by the userId field
        channelmembers = await ChannelMember.prisma().find_many(
            take=5,
            order={
                'userId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ChannelMemberWhereInput] = None,
        cursor: Optional[types.ChannelMemberWhereUniqueInput] = None,
        include: Optional[types.ChannelMemberInclude] = None,
        order: Optional[Union[types.ChannelMemberOrderByInput, List[types.ChannelMemberOrderByInput]]] = None,
        distinct: Optional[List[types.ChannelMemberScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single ChannelMember record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ChannelMember filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ChannelMember model
        order
            Order the returned ChannelMember records by any field
        distinct
            Filter ChannelMember records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ChannelMember
            The first ChannelMember record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ChannelMember record ordered by the channelId field
        channelmember = await ChannelMember.prisma().find_first(
            skip=1,
            order={
                'channelId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ChannelMemberWhereInput] = None,
        cursor: Optional[types.ChannelMemberWhereUniqueInput] = None,
        include: Optional[types.ChannelMemberInclude] = None,
        order: Optional[Union[types.ChannelMemberOrderByInput, List[types.ChannelMemberOrderByInput]]] = None,
        distinct: Optional[List[types.ChannelMemberScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single ChannelMember record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ChannelMember filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ChannelMember model
        order
            Order the returned ChannelMember records by any field
        distinct
            Filter ChannelMember records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ChannelMember
            The first ChannelMember record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ChannelMember record ordered by the id field
        channelmember = await ChannelMember.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ChannelMemberUpdateInput,
        where: types.ChannelMemberWhereUniqueInput,
        include: Optional[types.ChannelMemberInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single ChannelMember record.

        Parameters
        ----------
        data
            ChannelMember record data specifying what to update
        where
            ChannelMember filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned ChannelMember model

        Returns
        -------
        prisma.models.ChannelMember
            The updated ChannelMember record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        channelmember = await ChannelMember.prisma().update(
            where={
                'id': 'bggajdcbbi',
            },
            data={
                # data to update the ChannelMember record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ChannelMemberWhereUniqueInput,
        data: types.ChannelMemberUpsertInput,
        include: Optional[types.ChannelMemberInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            ChannelMember filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned ChannelMember model

        Returns
        -------
        prisma.models.ChannelMember
            The created or updated ChannelMember record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        channelmember = await ChannelMember.prisma().upsert(
            where={
                'id': 'fcfhgbjed',
            },
            data={
                'create': {
                    'id': 'fcfhgbjed',
                    'userId': 'deeificjd',
                    'channelId': 'bbcbhebbda',
                },
                'update': {
                    'userId': 'deeificjd',
                    'channelId': 'bbcbhebbda',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ChannelMemberUpdateManyMutationInput,
        where: types.ChannelMemberWhereInput,
    ) -> int:
        """Update multiple ChannelMember records

        Parameters
        ----------
        data
            ChannelMember data to update the selected ChannelMember records to
        where
            Filter to select the ChannelMember records to update

        Returns
        -------
        int
            The total number of ChannelMember records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all ChannelMember records
        total = await ChannelMember.prisma().update_many(
            data={
                'joinedAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ChannelMemberWhereInput] = None,
        cursor: Optional[types.ChannelMemberWhereUniqueInput] = None,
    ) -> int:
        """Count the number of ChannelMember records present in the database

        Parameters
        ----------
        select
            Select the ChannelMember fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ChannelMember filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ChannelMemberCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ChannelMember.prisma().count()

        # results: prisma.types.ChannelMemberCountAggregateOutput
        results = await ChannelMember.prisma().count(
            select={
                '_all': True,
                'userId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ChannelMemberCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ChannelMemberWhereInput] = None,
        cursor: Optional[types.ChannelMemberWhereUniqueInput] = None,
    ) -> types.ChannelMemberCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ChannelMemberCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ChannelMemberWhereInput] = None,
        cursor: Optional[types.ChannelMemberWhereUniqueInput] = None,
    ) -> Union[int, types.ChannelMemberCountAggregateOutput]:
        """Count the number of ChannelMember records present in the database

        Parameters
        ----------
        select
            Select the ChannelMember fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ChannelMember filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ChannelMemberCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ChannelMember.prisma().count()

        # results: prisma.types.ChannelMemberCountAggregateOutput
        results = await ChannelMember.prisma().count(
            select={
                '_all': True,
                'channelId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ChannelMemberCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ChannelMemberWhereInput] = None
    ) -> int:
        """Delete multiple ChannelMember records.

        Parameters
        ----------
        where
            Optional ChannelMember filter to find the records to be deleted

        Returns
        -------
        int
            The total number of ChannelMember records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all ChannelMember records
        total = await ChannelMember.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ChannelMemberScalarFieldKeys'],
        *,
        where: Optional['types.ChannelMemberWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ChannelMemberAvgAggregateInput'] = None,
        sum: Optional['types.ChannelMemberSumAggregateInput'] = None,
        min: Optional['types.ChannelMemberMinAggregateInput'] = None,
        max: Optional['types.ChannelMemberMaxAggregateInput'] = None,
        having: Optional['types.ChannelMemberScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ChannelMemberCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ChannelMemberScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.ChannelMemberScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.ChannelMemberGroupByOutput']:
        """Group ChannelMember records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar ChannelMember fields to group records by
        where
            ChannelMember filter to select records
        take
            Limit the maximum number of ChannelMember records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ChannelMemberGroupByOutput]
            A list of dictionaries representing the ChannelMember record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group ChannelMember records by id values
        # and count how many records are in each group
        results = await ChannelMember.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class MentionActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Mention]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Mention.prisma().query_raw(
            'SELECT * FROM Mention WHERE id = $1',
            'hdgcajhjg',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Mention
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Mention.prisma().query_first(
            'SELECT * FROM Mention WHERE createdAt = $1',
            datetime.datetime.utcnow(),
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.MentionCreateInput,
        include: Optional[types.MentionInclude] = None
    ) -> _PrismaModelT:
        """Create a new Mention record.

        Parameters
        ----------
        data
            Mention record data
        include
            Specifies which relations should be loaded on the returned Mention model

        Returns
        -------
        prisma.models.Mention
            The created Mention record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Mention record from just the required fields
        mention = await Mention.prisma().create(
            data={
                # data to create a Mention record
                'userId': 'ejdjahicb',
                'messageId': 'gdjgigfgc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.MentionCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Mention records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Mention record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Mention.prisma().create_many(
            data=[
                {
                    # data to create a Mention record
                    'userId': 'gfeaahdeh',
                    'messageId': 'bjafcgbffc',
                },
                {
                    # data to create a Mention record
                    'userId': 'hihegjif',
                    'messageId': 'bdjidcidac',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.MentionWhereUniqueInput,
        include: Optional[types.MentionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Mention record.

        Parameters
        ----------
        where
            Mention filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Mention model

        Returns
        -------
        prisma.models.Mention
            The deleted Mention record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        mention = await Mention.prisma().delete(
            where={
                'id': 'ifgaaagff',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.MentionWhereUniqueInput,
        include: Optional[types.MentionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Mention record.

        Parameters
        ----------
        where
            Mention filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Mention model

        Returns
        -------
        prisma.models.Mention
            The found Mention record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        mention = await Mention.prisma().find_unique(
            where={
                'id': 'befcddgjce',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.MentionWhereUniqueInput,
        include: Optional[types.MentionInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Mention record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Mention filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Mention model

        Returns
        -------
        prisma.models.Mention
            The found Mention record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        mention = await Mention.prisma().find_unique_or_raise(
            where={
                'id': 'bfhdbjjgfd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MentionWhereInput] = None,
        cursor: Optional[types.MentionWhereUniqueInput] = None,
        include: Optional[types.MentionInclude] = None,
        order: Optional[Union[types.MentionOrderByInput, List[types.MentionOrderByInput]]] = None,
        distinct: Optional[List[types.MentionScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Mention records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Mention records returned
        skip
            Ignore the first N results
        where
            Mention filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Mention model
        order
            Order the returned Mention records by any field
        distinct
            Filter Mention records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Mention]
            The list of all Mention records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Mention records
        mentions = await Mention.prisma().find_many(take=10)

        # find the first 5 Mention records ordered by the userId field
        mentions = await Mention.prisma().find_many(
            take=5,
            order={
                'userId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.MentionWhereInput] = None,
        cursor: Optional[types.MentionWhereUniqueInput] = None,
        include: Optional[types.MentionInclude] = None,
        order: Optional[Union[types.MentionOrderByInput, List[types.MentionOrderByInput]]] = None,
        distinct: Optional[List[types.MentionScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Mention record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Mention filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Mention model
        order
            Order the returned Mention records by any field
        distinct
            Filter Mention records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Mention
            The first Mention record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Mention record ordered by the messageId field
        mention = await Mention.prisma().find_first(
            skip=1,
            order={
                'messageId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.MentionWhereInput] = None,
        cursor: Optional[types.MentionWhereUniqueInput] = None,
        include: Optional[types.MentionInclude] = None,
        order: Optional[Union[types.MentionOrderByInput, List[types.MentionOrderByInput]]] = None,
        distinct: Optional[List[types.MentionScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Mention record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Mention filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Mention model
        order
            Order the returned Mention records by any field
        distinct
            Filter Mention records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Mention
            The first Mention record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Mention record ordered by the id field
        mention = await Mention.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.MentionUpdateInput,
        where: types.MentionWhereUniqueInput,
        include: Optional[types.MentionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Mention record.

        Parameters
        ----------
        data
            Mention record data specifying what to update
        where
            Mention filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Mention model

        Returns
        -------
        prisma.models.Mention
            The updated Mention record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        mention = await Mention.prisma().update(
            where={
                'id': 'cabdjadaji',
            },
            data={
                # data to update the Mention record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.MentionWhereUniqueInput,
        data: types.MentionUpsertInput,
        include: Optional[types.MentionInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Mention filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Mention model

        Returns
        -------
        prisma.models.Mention
            The created or updated Mention record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        mention = await Mention.prisma().upsert(
            where={
                'id': 'faajgfadf',
            },
            data={
                'create': {
                    'id': 'faajgfadf',
                    'userId': 'hihegjif',
                    'messageId': 'bdjidcidac',
                },
                'update': {
                    'userId': 'hihegjif',
                    'messageId': 'bdjidcidac',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.MentionUpdateManyMutationInput,
        where: types.MentionWhereInput,
    ) -> int:
        """Update multiple Mention records

        Parameters
        ----------
        data
            Mention data to update the selected Mention records to
        where
            Filter to select the Mention records to update

        Returns
        -------
        int
            The total number of Mention records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Mention records
        total = await Mention.prisma().update_many(
            data={
                'createdAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MentionWhereInput] = None,
        cursor: Optional[types.MentionWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Mention records present in the database

        Parameters
        ----------
        select
            Select the Mention fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Mention filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.MentionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Mention.prisma().count()

        # results: prisma.types.MentionCountAggregateOutput
        results = await Mention.prisma().count(
            select={
                '_all': True,
                'userId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.MentionCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MentionWhereInput] = None,
        cursor: Optional[types.MentionWhereUniqueInput] = None,
    ) -> types.MentionCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.MentionCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MentionWhereInput] = None,
        cursor: Optional[types.MentionWhereUniqueInput] = None,
    ) -> Union[int, types.MentionCountAggregateOutput]:
        """Count the number of Mention records present in the database

        Parameters
        ----------
        select
            Select the Mention fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Mention filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.MentionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Mention.prisma().count()

        # results: prisma.types.MentionCountAggregateOutput
        results = await Mention.prisma().count(
            select={
                '_all': True,
                'messageId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.MentionCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.MentionWhereInput] = None
    ) -> int:
        """Delete multiple Mention records.

        Parameters
        ----------
        where
            Optional Mention filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Mention records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Mention records
        total = await Mention.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.MentionScalarFieldKeys'],
        *,
        where: Optional['types.MentionWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.MentionAvgAggregateInput'] = None,
        sum: Optional['types.MentionSumAggregateInput'] = None,
        min: Optional['types.MentionMinAggregateInput'] = None,
        max: Optional['types.MentionMaxAggregateInput'] = None,
        having: Optional['types.MentionScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.MentionCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.MentionScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.MentionScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.MentionGroupByOutput']:
        """Group Mention records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Mention fields to group records by
        where
            Mention filter to select records
        take
            Limit the maximum number of Mention records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.MentionGroupByOutput]
            A list of dictionaries representing the Mention record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Mention records by id values
        # and count how many records are in each group
        results = await Mention.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class MessageReactionActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.MessageReaction]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await MessageReaction.prisma().query_raw(
            'SELECT * FROM MessageReaction WHERE id = $1',
            'biaagcedjc',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.MessageReaction
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await MessageReaction.prisma().query_first(
            'SELECT * FROM MessageReaction WHERE emoji = $1',
            'cahhaghecf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.MessageReactionCreateInput,
        include: Optional[types.MessageReactionInclude] = None
    ) -> _PrismaModelT:
        """Create a new MessageReaction record.

        Parameters
        ----------
        data
            MessageReaction record data
        include
            Specifies which relations should be loaded on the returned MessageReaction model

        Returns
        -------
        prisma.models.MessageReaction
            The created MessageReaction record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a MessageReaction record from just the required fields
        messagereaction = await MessageReaction.prisma().create(
            data={
                # data to create a MessageReaction record
                'emoji': 'bghcbbcidi',
                'userId': 'jcgghhgdj',
                'messageId': 'beehgcebbg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.MessageReactionCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple MessageReaction records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of MessageReaction record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await MessageReaction.prisma().create_many(
            data=[
                {
                    # data to create a MessageReaction record
                    'emoji': 'bhdiaidiaf',
                    'userId': 'deajegcfi',
                    'messageId': 'gabahhhjf',
                },
                {
                    # data to create a MessageReaction record
                    'emoji': 'cjagadcjg',
                    'userId': 'bifficggej',
                    'messageId': 'bgbbaajbic',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.MessageReactionWhereUniqueInput,
        include: Optional[types.MessageReactionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single MessageReaction record.

        Parameters
        ----------
        where
            MessageReaction filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned MessageReaction model

        Returns
        -------
        prisma.models.MessageReaction
            The deleted MessageReaction record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        messagereaction = await MessageReaction.prisma().delete(
            where={
                'id': 'eegghdhjb',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.MessageReactionWhereUniqueInput,
        include: Optional[types.MessageReactionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique MessageReaction record.

        Parameters
        ----------
        where
            MessageReaction filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned MessageReaction model

        Returns
        -------
        prisma.models.MessageReaction
            The found MessageReaction record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        messagereaction = await MessageReaction.prisma().find_unique(
            where={
                'id': 'daafgidjg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.MessageReactionWhereUniqueInput,
        include: Optional[types.MessageReactionInclude] = None
    ) -> _PrismaModelT:
        """Find a unique MessageReaction record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            MessageReaction filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned MessageReaction model

        Returns
        -------
        prisma.models.MessageReaction
            The found MessageReaction record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        messagereaction = await MessageReaction.prisma().find_unique_or_raise(
            where={
                'id': 'gdcgcgagj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MessageReactionWhereInput] = None,
        cursor: Optional[types.MessageReactionWhereUniqueInput] = None,
        include: Optional[types.MessageReactionInclude] = None,
        order: Optional[Union[types.MessageReactionOrderByInput, List[types.MessageReactionOrderByInput]]] = None,
        distinct: Optional[List[types.MessageReactionScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple MessageReaction records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of MessageReaction records returned
        skip
            Ignore the first N results
        where
            MessageReaction filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned MessageReaction model
        order
            Order the returned MessageReaction records by any field
        distinct
            Filter MessageReaction records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.MessageReaction]
            The list of all MessageReaction records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 MessageReaction records
        messagereactions = await MessageReaction.prisma().find_many(take=10)

        # find the first 5 MessageReaction records ordered by the createdAt field
        messagereactions = await MessageReaction.prisma().find_many(
            take=5,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.MessageReactionWhereInput] = None,
        cursor: Optional[types.MessageReactionWhereUniqueInput] = None,
        include: Optional[types.MessageReactionInclude] = None,
        order: Optional[Union[types.MessageReactionOrderByInput, List[types.MessageReactionOrderByInput]]] = None,
        distinct: Optional[List[types.MessageReactionScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single MessageReaction record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            MessageReaction filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned MessageReaction model
        order
            Order the returned MessageReaction records by any field
        distinct
            Filter MessageReaction records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.MessageReaction
            The first MessageReaction record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second MessageReaction record ordered by the userId field
        messagereaction = await MessageReaction.prisma().find_first(
            skip=1,
            order={
                'userId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.MessageReactionWhereInput] = None,
        cursor: Optional[types.MessageReactionWhereUniqueInput] = None,
        include: Optional[types.MessageReactionInclude] = None,
        order: Optional[Union[types.MessageReactionOrderByInput, List[types.MessageReactionOrderByInput]]] = None,
        distinct: Optional[List[types.MessageReactionScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single MessageReaction record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            MessageReaction filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned MessageReaction model
        order
            Order the returned MessageReaction records by any field
        distinct
            Filter MessageReaction records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.MessageReaction
            The first MessageReaction record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second MessageReaction record ordered by the messageId field
        messagereaction = await MessageReaction.prisma().find_first_or_raise(
            skip=1,
            order={
                'messageId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.MessageReactionUpdateInput,
        where: types.MessageReactionWhereUniqueInput,
        include: Optional[types.MessageReactionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single MessageReaction record.

        Parameters
        ----------
        data
            MessageReaction record data specifying what to update
        where
            MessageReaction filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned MessageReaction model

        Returns
        -------
        prisma.models.MessageReaction
            The updated MessageReaction record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        messagereaction = await MessageReaction.prisma().update(
            where={
                'id': 'bhceabbgja',
            },
            data={
                # data to update the MessageReaction record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.MessageReactionWhereUniqueInput,
        data: types.MessageReactionUpsertInput,
        include: Optional[types.MessageReactionInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            MessageReaction filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned MessageReaction model

        Returns
        -------
        prisma.models.MessageReaction
            The created or updated MessageReaction record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        messagereaction = await MessageReaction.prisma().upsert(
            where={
                'id': 'ehabfhegh',
            },
            data={
                'create': {
                    'id': 'ehabfhegh',
                    'emoji': 'cjagadcjg',
                    'userId': 'bifficggej',
                    'messageId': 'bgbbaajbic',
                },
                'update': {
                    'emoji': 'cjagadcjg',
                    'userId': 'bifficggej',
                    'messageId': 'bgbbaajbic',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.MessageReactionUpdateManyMutationInput,
        where: types.MessageReactionWhereInput,
    ) -> int:
        """Update multiple MessageReaction records

        Parameters
        ----------
        data
            MessageReaction data to update the selected MessageReaction records to
        where
            Filter to select the MessageReaction records to update

        Returns
        -------
        int
            The total number of MessageReaction records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all MessageReaction records
        total = await MessageReaction.prisma().update_many(
            data={
                'id': 'bcajcajjbc'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MessageReactionWhereInput] = None,
        cursor: Optional[types.MessageReactionWhereUniqueInput] = None,
    ) -> int:
        """Count the number of MessageReaction records present in the database

        Parameters
        ----------
        select
            Select the MessageReaction fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            MessageReaction filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.MessageReactionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await MessageReaction.prisma().count()

        # results: prisma.types.MessageReactionCountAggregateOutput
        results = await MessageReaction.prisma().count(
            select={
                '_all': True,
                'emoji': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.MessageReactionCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MessageReactionWhereInput] = None,
        cursor: Optional[types.MessageReactionWhereUniqueInput] = None,
    ) -> types.MessageReactionCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.MessageReactionCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MessageReactionWhereInput] = None,
        cursor: Optional[types.MessageReactionWhereUniqueInput] = None,
    ) -> Union[int, types.MessageReactionCountAggregateOutput]:
        """Count the number of MessageReaction records present in the database

        Parameters
        ----------
        select
            Select the MessageReaction fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            MessageReaction filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.MessageReactionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await MessageReaction.prisma().count()

        # results: prisma.types.MessageReactionCountAggregateOutput
        results = await MessageReaction.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.MessageReactionCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.MessageReactionWhereInput] = None
    ) -> int:
        """Delete multiple MessageReaction records.

        Parameters
        ----------
        where
            Optional MessageReaction filter to find the records to be deleted

        Returns
        -------
        int
            The total number of MessageReaction records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all MessageReaction records
        total = await MessageReaction.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.MessageReactionScalarFieldKeys'],
        *,
        where: Optional['types.MessageReactionWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.MessageReactionAvgAggregateInput'] = None,
        sum: Optional['types.MessageReactionSumAggregateInput'] = None,
        min: Optional['types.MessageReactionMinAggregateInput'] = None,
        max: Optional['types.MessageReactionMaxAggregateInput'] = None,
        having: Optional['types.MessageReactionScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.MessageReactionCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.MessageReactionScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.MessageReactionScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.MessageReactionGroupByOutput']:
        """Group MessageReaction records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar MessageReaction fields to group records by
        where
            MessageReaction filter to select records
        take
            Limit the maximum number of MessageReaction records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.MessageReactionGroupByOutput]
            A list of dictionaries representing the MessageReaction record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group MessageReaction records by userId values
        # and count how many records are in each group
        results = await MessageReaction.prisma().group_by(
            ['userId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]



def _select_fields(root: str, select: Mapping[str, Any]) -> str:
    """Helper to build a GraphQL selection string

    This is a work around until field selection is added to the query builder.
    """

    return root + ' {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))


from . import models